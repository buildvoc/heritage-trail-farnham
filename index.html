<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Deck.gl Building Preview</title>
    <link
      rel="stylesheet"
      href="vendor/deck.gl-widgets@9.2.2/deck.gl-widgets.min.css"
    />
    <script src="vendor/deck.gl@9.2.2/deck.gl.min.js"></script>
    <script src="vendor/deck.gl-widgets@9.2.2/deck.gl-widgets.min.js"></script>
    <script>
      if (window.deck && window.deckWidgets) {
        window.deck.widgets = window.deckWidgets;
      }
    </script>
    <script src="pic2bim-building.js"></script>
    <!--
      Copy pic2bim-credentials.sample.js to pic2bim-credentials.local.js and
      update it to define window.pic2bimCredentials with
      { username: "...", password: "..." }. The local file should never be
      committed.
    -->
    <script src="pic2bim-credentials.local.js" defer></script>
    <style>
      :root {
        color-scheme: dark;
      }

      html,
      body {
        margin: 0;
        height: 100%;
        background-color: #0f172a;
        font-family:
          system-ui,
          -apple-system,
          BlinkMacSystemFont,
          "Segoe UI",
          sans-serif;
      }

      #deck-container {
        position: absolute;
        inset: 0;
      }

      #building-controls {
        position: absolute;
        top: 16px;
        left: 16px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 14px 16px;
        border-radius: 12px;
        background-color: rgba(15, 23, 42, 0.85);
        backdrop-filter: blur(6px);
        color: #f8fafc;
        max-width: min(340px, 80vw);
        z-index: 5;
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.35);
      }

      #building-controls button {
        padding: 10px 14px;
        border: none;
        border-radius: 6px;
        font-size: 0.95rem;
        font-weight: 600;
        color: #0f172a;
        background-color: #fbbf24;
        cursor: pointer;
      }

      #building-controls button:disabled {
        opacity: 0.6;
        cursor: progress;
      }

      #building-status {
        font-size: 0.85rem;
        line-height: 1.3;
        min-height: 1.3em;
        color: #bbf7d0;
      }

      #reset-view-widget {
        min-height: 36px;
      }
    </style>
  </head>
  <body>
    <div id="deck-container" aria-label="deck.gl scene"></div>
    <div id="building-controls">
      <button id="fetch-building" type="button">
        Fetch nearest building (pic2bim API)
      </button>
      <div id="building-status" role="status" aria-live="polite"></div>
      <div id="reset-view-widget" aria-live="polite"></div>
    </div>
    <script>
      (function () {
        const {
          Deck,
          MapController,
          MapView,
          PolygonLayer,
          COORDINATE_SYSTEM,
        } = deck;

        const helperNamespace = window.pic2bimBuilding ?? {};
        const fetchNearestBuilding =
          typeof helperNamespace.fetchNearestBuilding === "function"
            ? helperNamespace.fetchNearestBuilding
            : null;
        const normalizeBuildingFeatures =
          typeof helperNamespace.normalizeBuildingFeatures === "function"
            ? helperNamespace.normalizeBuildingFeatures
            : () => [];
        const parseBuildingHeight =
          typeof helperNamespace.parseBuildingHeight === "function"
            ? helperNamespace.parseBuildingHeight
            : () => 12;

        const deckContainer = document.getElementById("deck-container");
        const fetchButton = document.getElementById("fetch-building");
        const statusElement = document.getElementById("building-status");
        const widgetContainer = document.getElementById("reset-view-widget");

        const mainViewId = "deck-main-view";
        const staticBuildingDataUrl =
          "https://raw.githubusercontent.com/buildvoc/heritage-trail-farnham/main/osm_st_andrews_church_osm_2025_10_31.geojson";

        const initialViewState = {
          longitude: -0.79502,
          latitude: 51.21699,
          zoom: 18.25,
          pitch: 60,
          bearing: 24,
        };

        let deckViewState = { ...initialViewState };
        const keyedInitialViewState = { [mainViewId]: { ...deckViewState } };
        let currentBuildingLayer = null;
        let resetWidget = null;
        let deckInstance = null;

        const setStatus = (message, { isError = false } = {}) => {
          if (!statusElement) {
            return;
          }
          statusElement.textContent = message;
          statusElement.style.color = isError ? "#fca5a5" : "#bbf7d0";
        };

        const buildingLayerId = "pic2bim-building";

        const tooltipFormatter = (info) => {
          const feature = info?.object;
          if (!feature || info.layer?.id !== buildingLayerId) {
            return null;
          }
          const properties = feature.properties ?? {};
          const name =
            properties.name ||
            properties.ref ||
            properties["addr:housename"] ||
            "Building";
          const height = parseBuildingHeight(properties);
          const levels =
            properties.building_levels ||
            properties.levels ||
            properties["building:levels"];
          const details = [`Building: ${name}`];
          if (Number.isFinite(height)) {
            details.push(`Height: ${Math.round(height * 100) / 100} m`);
          }
          if (levels) {
            details.push(`Levels: ${levels}`);
          }
          return details.join("\n");
        };

        const clampZoom = (value) => {
          const number = Number(value);
          if (!Number.isFinite(number)) {
            return deckViewState.zoom;
          }
          return Math.min(Math.max(number, 0), 22);
        };

        const accumulateBounds = (bounds, coordinates) => {
          if (!coordinates) {
            return bounds;
          }
          if (typeof coordinates[0] === "number") {
            const [lng, lat] = coordinates;
            if (Number.isFinite(lng) && Number.isFinite(lat)) {
              bounds.minLng = Math.min(bounds.minLng, lng);
              bounds.maxLng = Math.max(bounds.maxLng, lng);
              bounds.minLat = Math.min(bounds.minLat, lat);
              bounds.maxLat = Math.max(bounds.maxLat, lat);
            }
            return bounds;
          }
          for (const entry of coordinates) {
            accumulateBounds(bounds, entry);
          }
          return bounds;
        };

        const computeFeatureBounds = (features) => {
          const bounds = {
            minLng: Number.POSITIVE_INFINITY,
            maxLng: Number.NEGATIVE_INFINITY,
            minLat: Number.POSITIVE_INFINITY,
            maxLat: Number.NEGATIVE_INFINITY,
          };
          for (const feature of features) {
            accumulateBounds(bounds, feature?.geometry?.coordinates);
          }
          if (
            !Number.isFinite(bounds.minLng) ||
            !Number.isFinite(bounds.maxLng) ||
            !Number.isFinite(bounds.minLat) ||
            !Number.isFinite(bounds.maxLat)
          ) {
            return null;
          }
          return bounds;
        };

        const prepareBuildingLayer = (geojson) => {
          const features = normalizeBuildingFeatures(geojson);
          if (!Array.isArray(features) || features.length === 0) {
            return { layer: null, focusTarget: null };
          }
          const layer = new PolygonLayer({
            id: buildingLayerId,
            data: features,
            extruded: true,
            wireframe: true,
            filled: true,
            autoHighlight: true,
            coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
            getPolygon: (feature) => feature?.geometry?.coordinates,
            getElevation: (feature) =>
              parseBuildingHeight(feature?.properties ?? {}),
            getFillColor: [249, 115, 22, 140],
            getLineColor: [255, 255, 255, 220],
            lineWidthMinPixels: 1,
            highlightColor: [59, 130, 246, 200],
            material: {
              ambient: 0.4,
              diffuse: 0.6,
              shininess: 32,
            },
            pickable: true,
          });

          const bounds = computeFeatureBounds(features);
          if (!bounds) {
            return { layer, focusTarget: null };
          }
          const focusTarget = {
            longitude: (bounds.minLng + bounds.maxLng) / 2,
            latitude: (bounds.minLat + bounds.maxLat) / 2,
            zoom: Math.max(
              deckViewState.zoom ?? initialViewState.zoom ?? 16,
              18,
            ),
            bearing: deckViewState.bearing ?? initialViewState.bearing,
            pitch: deckViewState.pitch ?? initialViewState.pitch,
          };
          return { layer, focusTarget };
        };

        const updateDeckLayers = () => {
          if (!deckInstance) {
            return;
          }
          const layers = currentBuildingLayer ? [currentBuildingLayer] : [];
          deckInstance.setProps({ layers });
        };

        const syncViewState = () => {
          if (!deckInstance) {
            return;
          }
          const keyedState = { [mainViewId]: { ...deckViewState } };
          deckInstance.setProps({ viewState: keyedState });
          if (resetWidget && typeof resetWidget.setProps === "function") {
            resetWidget.setProps({
              viewId: mainViewId,
              viewState: keyedState,
              initialViewState: keyedInitialViewState,
            });
          }
        };

        const applyViewState = (updates = {}) => {
          deckViewState = { ...deckViewState, ...updates };
          syncViewState();
        };

        const focusOnTarget = (target) => {
          if (!target) {
            return;
          }
          const hasLngLat =
            Number.isFinite(target.longitude) &&
            Number.isFinite(target.latitude);
          applyViewState({
            longitude: hasLngLat ? target.longitude : deckViewState.longitude,
            latitude: hasLngLat ? target.latitude : deckViewState.latitude,
            zoom: clampZoom(target.zoom ?? deckViewState.zoom),
            bearing: Number.isFinite(target.bearing)
              ? target.bearing
              : deckViewState.bearing,
            pitch: Number.isFinite(target.pitch)
              ? target.pitch
              : deckViewState.pitch,
          });
        };

        const ensureResetViewWidget = () => {
          const widgetsNamespace = deck.widgets;
          if (
            !widgetsNamespace ||
            typeof widgetsNamespace.ResetViewWidget !== "function"
          ) {
            console.warn(
              "ResetViewWidget is unavailable in the current deck.gl build.",
            );
            return;
          }
          if (!widgetContainer) {
            console.warn("ResetViewWidget container element is missing.");
            return;
          }
          if (!resetWidget) {
            resetWidget = new widgetsNamespace.ResetViewWidget({
              container: widgetContainer,
              viewId: mainViewId,
              initialViewState: keyedInitialViewState,
              label: "Reset view",
            });
          } else {
            resetWidget.setProps({
              container: widgetContainer,
              viewId: mainViewId,
              initialViewState: keyedInitialViewState,
            });
          }
          if (deckInstance) {
            deckInstance.setProps({ widgets: [resetWidget] });
          }
          syncViewState();
        };

        const loadSampleBuildingLayer = async () => {
          setStatus("Loading sample building footprint…");
          try {
            const response = await fetch(staticBuildingDataUrl);
            if (!response.ok) {
              throw new Error(
                `Failed to load sample dataset (${response.status}).`,
              );
            }
            const geojson = await response.json();
            const { layer, focusTarget } = prepareBuildingLayer(geojson);
            if (!layer) {
              currentBuildingLayer = null;
              updateDeckLayers();
              setStatus(
                "Sample dataset did not contain polygon geometry for extrusion.",
                { isError: true },
              );
              return;
            }
            currentBuildingLayer = layer;
            updateDeckLayers();
            setStatus(
              "Loaded sample building footprint. Provide pic2bim credentials locally to fetch live buildings.",
            );
            if (focusTarget) {
              focusOnTarget(focusTarget);
            }
          } catch (error) {
            console.error(
              "Unable to load the sample building footprint",
              error,
            );
            currentBuildingLayer = null;
            updateDeckLayers();
            setStatus(
              "Unable to load the sample building footprint. Provide pic2bim credentials locally to fetch live buildings.",
              { isError: true },
            );
          }
        };

        const handleBuildingFetch = async () => {
          if (!fetchButton) {
            return;
          }
          fetchButton.disabled = true;
          setStatus("Fetching building data…");
          try {
            if (typeof fetchNearestBuilding !== "function") {
              throw new Error("Building fetch helpers are unavailable.");
            }
            const result = await fetchNearestBuilding({
              latitude: deckViewState.latitude,
              longitude: deckViewState.longitude,
              bearing: deckViewState.bearing,
            });
            if (!result) {
              currentBuildingLayer = null;
              updateDeckLayers();
              setStatus("No building data available for the current view.", {
                isError: true,
              });
              return;
            }
            const { layer, focusTarget } = prepareBuildingLayer(result.geojson);
            if (!layer) {
              currentBuildingLayer = null;
              updateDeckLayers();
              setStatus(
                "No polygon geometry returned for the nearest building.",
                { isError: true },
              );
              return;
            }
            currentBuildingLayer = layer;
            updateDeckLayers();
            const featureName =
              result.geojson?.features?.[0]?.properties?.name ||
              result.geojson?.properties?.name ||
              "Building";
            setStatus(`Loaded building data for ${featureName}.`);
            if (focusTarget) {
              focusOnTarget(focusTarget);
            }
          } catch (error) {
            console.error("Building fetch failed", error);
            setStatus(
              error instanceof Error ? error.message : "Building fetch failed.",
              { isError: true },
            );
          } finally {
            fetchButton.disabled = false;
          }
        };

        if (fetchButton) {
          fetchButton.addEventListener("click", handleBuildingFetch);
          if (!fetchNearestBuilding) {
            fetchButton.disabled = true;
            fetchButton.title =
              "Provide pic2bim credentials locally to enable live building fetches.";
          }
        }

        deckInstance = new Deck({
          parent: deckContainer,
          views: [new MapView({ id: mainViewId })],
          controller: {
            type: MapController,
            dragPan: true,
            dragRotate: true,
            scrollZoom: true,
            keyboard: true,
            doubleClickZoom: true,
            touchZoom: true,
            touchRotate: true,
          },
          viewState: keyedInitialViewState,
          layers: [],
          getTooltip: tooltipFormatter,
          onViewStateChange: ({ viewId, viewState }) => {
            if (viewId && viewId !== mainViewId) {
              return;
            }
            deckViewState = { ...viewState };
            syncViewState();
          },
        });

        ensureResetViewWidget();
        loadSampleBuildingLayer();
      })();
    </script>
  </body>
</html>
