<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>deck.gl GeoJsonLayer (polygons) example</title>
    <link rel="stylesheet" href="vendor/maplibre-gl@3.6.2/maplibre-gl.css" />
    <link
      rel="stylesheet"
      href="vendor/deck.gl-widgets@9.2.2/deck.gl-widgets.min.css"
    />
    <style>
      :root {
        color-scheme: dark;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        background: #020617;
        color: #f8fafc;
        font-family:
          "Inter",
          system-ui,
          -apple-system,
          BlinkMacSystemFont,
          "Segoe UI",
          sans-serif;
      }

      #app {
        position: relative;
        height: 100%;
        width: 100%;
      }

      #deck-container {
        position: absolute;
        inset: 0;
      }

      #control-panel {
        position: absolute;
        top: 16px;
        left: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px 18px;
        width: min(320px, 90vw);
        background: rgba(2, 6, 23, 0.84);
        border-radius: 12px;
        backdrop-filter: blur(6px);
        box-shadow: 0 16px 40px rgba(15, 23, 42, 0.4);
        z-index: 5;
      }

      #control-panel h1 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
      }

      #control-panel p {
        margin: 0;
        font-size: 0.9rem;
        line-height: 1.45;
        color: #cbd5f5;
      }

      #example-link {
        font-size: 0.85rem;
        color: #38bdf8;
        text-decoration: none;
      }

      #example-link:hover,
      #example-link:focus {
        text-decoration: underline;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      #widget-container {
        display: flex;
        gap: 12px;
      }

      .deck-widget {
        --deck-widget-control-bg: rgba(15, 23, 42, 0.9);
        --deck-widget-control-color: #f8fafc;
        --deck-widget-control-border: rgba(148, 163, 184, 0.2);
      }
    </style>
    <script src="vendor/maplibre-gl@3.6.2/maplibre-gl.js"></script>
    <script>
      window.mapboxgl = window.maplibregl;
    </script>
    <script src="vendor/deck.gl@9.2.2/deck.gl.min.js"></script>
    <script src="vendor/deck.gl-widgets@9.2.2/deck.gl-widgets.min.js"></script>
    <script>
      (function bridgeWidgetNamespace() {
        const connect = () => {
          if (!window.deck || !window.deckWidgets) {
            return;
          }

          window.deck.widgets = {
            ...(window.deck.widgets || {}),
            ...window.deckWidgets,
          };
        };

        connect();
        window.addEventListener("load", connect, { once: true });
      })();
    </script>
  </head>
  <body>
    <div id="app">
      <div
        id="deck-container"
        aria-label="deck.gl GeoJsonLayer polygons example"
      ></div>
      <div id="control-panel">
        <h1 id="example-title">GeoJsonLayer (polygons)</h1>
        <p id="example-description">
          Loading deck.gl GeoJsonLayer configuration from the playgroundâ€¦
        </p>
        <a
          id="example-link"
          class="sr-only"
          href="https://deck.gl/#/examples/core-layers/geojson-layer-polygons"
          rel="noreferrer"
          target="_blank"
        ></a>
        <div id="widget-container"></div>
      </div>
    </div>
    <script>
      (function main() {
        const CONFIG_URL =
          "https://raw.githubusercontent.com/visgl/deck.gl/master/examples/playground/json-examples/geojson.json";

        const widgetContainer = document.getElementById("widget-container");
        const titleEl = document.getElementById("example-title");
        const descriptionEl = document.getElementById("example-description");
        const linkEl = document.getElementById("example-link");

        const getPath = (object, path) => {
          if (!object) {
            return undefined;
          }

          return path.split(".").reduce((acc, key) => acc?.[key], object);
        };

        const expressionToAccessor = (expression) => {
          const trimmed = expression.trim();

          if (trimmed === "-") {
            return (object) => object;
          }

          if (trimmed.startsWith("[") && trimmed.endsWith("]")) {
            const entries = trimmed
              .slice(1, -1)
              .split(",")
              .map((token) => token.trim())
              .filter(Boolean);
            return (object) => entries.map((entry) => getPath(object, entry));
          }

          return (object) => getPath(object, trimmed);
        };

        const toAccessor = (value) => {
          if (typeof value === "string" && value.startsWith("@@=")) {
            const expression = value.slice("@@=".length);
            return expressionToAccessor(expression);
          }

          if (typeof value === "string" && value.startsWith("@@type")) {
            return value;
          }

          return value;
        };

        const instantiateLayer = (layerConfig = {}) => {
          const { "@@type": type, id = "layer", ...rest } = layerConfig;
          const resolvedProps = Object.fromEntries(
            Object.entries(rest).map(([key, value]) => [
              key,
              toAccessor(value),
            ]),
          );

          switch (type) {
            case "GeoJsonLayer":
              return new deck.GeoJsonLayer({ id, ...resolvedProps });
            case "ScatterplotLayer":
              return new deck.ScatterplotLayer({ id, ...resolvedProps });
            case "LineLayer":
              return new deck.LineLayer({ id, ...resolvedProps });
            default:
              console.warn(`Unsupported layer type: ${type}`);
              return null;
          }
        };

        const instantiateView = (viewConfig = {}) => {
          const { "@@type": type, ...rest } = viewConfig;
          switch (type) {
            case "MapView": {
              const { mapStyle, ...viewProps } = rest;
              return {
                view: new deck.MapView(viewProps),
                mapStyle,
              };
            }
            default:
              console.warn(`Unsupported view type: ${type}`);
              return null;
          }
        };

        const instantiateWidgets = (widgetConfigs = []) => {
          if (!deck.widgets || widgetConfigs.length === 0) {
            return [];
          }

          const available = deck.widgets;
          return widgetConfigs
            .map(({ "@@type": type, ...widgetProps }) => {
              const WidgetCtor = available[type];
              if (!WidgetCtor) {
                console.warn(`Unsupported widget type: ${type}`);
                return null;
              }

              return new WidgetCtor({
                container: widgetContainer,
                ...widgetProps,
              });
            })
            .filter(Boolean);
        };

        const updateMetadata = ({ description, websiteUrl }) => {
          if (description) {
            titleEl.textContent = "GeoJsonLayer (polygons)";
            descriptionEl.textContent = description;
          }

          if (websiteUrl) {
            linkEl.textContent = "View on deck.gl";
            linkEl.classList.remove("sr-only");
            linkEl.href = websiteUrl;
          }
        };

        const bootstrap = async () => {
          let config;
          try {
            const response = await fetch(CONFIG_URL);
            if (!response.ok) {
              throw new Error(`Failed to load config: ${response.status}`);
            }

            config = await response.json();
          } catch (error) {
            console.error("Unable to load playground config", error);
            descriptionEl.textContent =
              "Failed to load the deck.gl playground configuration.";
            return;
          }

          updateMetadata(config);

          const views = [];
          const mapStyles = [];
          const viewConfigs = Array.isArray(config.views)
            ? config.views
            : config.views
              ? [config.views]
              : [];
          for (const viewConfig of viewConfigs) {
            const instantiated = instantiateView(viewConfig);
            if (!instantiated) {
              continue;
            }

            if (instantiated.view) {
              views.push(instantiated.view);
            }

            if (instantiated.mapStyle) {
              mapStyles.push(instantiated.mapStyle);
            }
          }
          const layerConfigs = Array.isArray(config.layers)
            ? config.layers
            : config.layers
              ? [config.layers]
              : [];
          const layers = layerConfigs.map(instantiateLayer).filter(Boolean);
          const widgetConfigs = Array.isArray(config.widgets)
            ? config.widgets
            : config.widgets
              ? [config.widgets]
              : [];
          const widgets = instantiateWidgets(widgetConfigs);

          const deckProps = {
            container: "deck-container",
            initialViewState: config.initialViewState,
            controller:
              typeof config.controller !== "undefined"
                ? config.controller
                : true,
          };

          if (views.length > 0) {
            deckProps.views = views;
          }

          if (layers.length > 0) {
            deckProps.layers = layers;
          }

          if (widgets.length > 0) {
            deckProps.widgets = widgets;
          }

          if (config.map || mapStyles.length > 0) {
            deckProps.map = window.maplibregl;
          }

          if (mapStyles.length > 0) {
            deckProps.mapStyle = mapStyles[0];
          } else if (config.mapStyle) {
            deckProps.mapStyle = config.mapStyle;
          }

          if (typeof config.pickingRadius === "number") {
            deckProps.pickingRadius = config.pickingRadius;
          }

          new deck.Deck(deckProps);
        };

        bootstrap();
      })();
    </script>
  </body>
</html>
