<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Display a 3D Map</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.css"
      crossorigin="anonymous"
    />
    <script
      src="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.js"
      crossorigin="anonymous"
    ></script>
    <script src="https://unpkg.com/pmtiles@4.1.0/dist/pmtiles.js"></script>
    <script src="https://unpkg.com/deck.gl@9.0.37/dist.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
      }

      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }

      #deck-tooltip {
        position: absolute;
        z-index: 2;
        pointer-events: none;
        background: rgba(0, 0, 0, 0.75);
        color: #ffffff;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        transform: translate(-50%, calc(-100% - 8px));
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script>
      const protocol = new pmtiles.Protocol();
      maplibregl.addProtocol("pmtiles", protocol.tile);
      const pmtilesUrl = "output.pmtiles";
      const pmtilesSource = new pmtiles.PMTiles(pmtilesUrl);
      protocol.add(pmtilesSource);

      const trailDataUrl =
        "LAD_Waverley_active-travel-heritage-trail-farnham.geojson";

      const map = new maplibregl.Map({
        style: "https://tiles.openfreemap.org/styles/liberty",
        container: "map", // container id
        center: [-0.796, 51.214],
        zoom: 16,
        pitch: 61,
        bearing: 0,
        maxPitch: 85,
        maxZoom: 20,
      });

      const mapContainer = document.getElementById("map");

      const deckCanvas = document.createElement("canvas");
      deckCanvas.id = "deck-canvas";
      deckCanvas.style.position = "absolute";
      deckCanvas.style.top = "0";
      deckCanvas.style.left = "0";
      deckCanvas.style.width = "100%";
      deckCanvas.style.height = "100%";
      deckCanvas.style.pointerEvents = "auto";
      deckCanvas.style.backgroundColor = "transparent";
      mapContainer.appendChild(deckCanvas);

      const tooltip = document.createElement("div");
      tooltip.id = "deck-tooltip";
      mapContainer.appendChild(tooltip);

      let deckReady = false;
      let deckSyncInProgress = false;
      let mapSyncInProgress = false;

      const TerrainExtension = deck._TerrainExtension || deck.TerrainExtension;
      const terrainExtension = TerrainExtension
        ? new TerrainExtension({ terrainDrawMode: "offset" })
        : null;

      const deckgl = new deck.Deck({
        canvas: deckCanvas,
        width: "100%",
        height: "100%",
        glOptions: {
          alpha: true,
        },
        parameters: {
          clearColor: [0, 0, 0, 0],
        },
        controller: {
          type: deck.OrbitController,
          dragMode: "pan",
          keyboard: false,
        },
        onViewStateChange: ({ viewState }) => {
          if (!deckReady || mapSyncInProgress) {
            return;
          }

          if (!Array.isArray(viewState.target)) {
            return;
          }

          deckSyncInProgress = true;
          try {
            const targetCoordinate = new maplibregl.MercatorCoordinate(
              viewState.target[0],
              viewState.target[1],
              viewState.target[2] ?? 0,
            ).toLngLat();

            map.jumpTo({
              center: [targetCoordinate.lng, targetCoordinate.lat],
              zoom: viewState.zoom,
              pitch: viewState.rotationX,
              bearing: viewState.rotationOrbit,
            });
          } finally {
            deckSyncInProgress = false;
          }
        },
        views: [
          new deck.OrbitView({
            id: "orbit-view",
            fov: 50,
          }),
        ],
        layers: [],
      });

      const getPmtilesInstance = (() => {
        const cache = new Map();
        return (archivePath) => {
          if (cache.has(archivePath)) {
            return cache.get(archivePath);
          }
          const instance =
            protocol.get(archivePath) ?? new pmtiles.PMTiles(archivePath);
          protocol.add(instance);
          cache.set(archivePath, instance);
          return instance;
        };
      })();

      const pmtilesImageResponse = (tile) => {
        if (!tile || !tile.data) {
          return new Response(null, { status: 204 });
        }

        const dataView =
          tile.data instanceof ArrayBuffer
            ? tile.data
            : tile.data.buffer.slice(
                tile.data.byteOffset,
                tile.data.byteOffset + tile.data.byteLength,
              );

        const headers = new Headers({ "Content-Type": "image/png" });
        if (tile.cacheControl) {
          headers.set("Cache-Control", tile.cacheControl);
        }
        if (tile.expires) {
          headers.set("Expires", tile.expires);
        }

        return new Response(dataView, { status: 200, headers });
      };

      const pmtilesFetch = async (url, options = {}) => {
        if (!url.startsWith("pmtiles://")) {
          return fetch(url, options);
        }

        const matches = url.match(/^pmtiles:\/\/(.+?)\/(\d+)\/(\d+)\/(\d+)$/);
        if (!matches) {
          throw new Error(`Unexpected PMTiles request: ${url}`);
        }

        const [, archivePath, z, x, y] = matches;
        const archive = getPmtilesInstance(archivePath);
        const tile = await archive.getZxy(
          Number.parseInt(z, 10),
          Number.parseInt(x, 10),
          Number.parseInt(y, 10),
          options.signal,
        );

        return pmtilesImageResponse(tile);
      };

      const createTerrainLayer = () => {
        if (typeof deck.TerrainLayer !== "function") {
          console.warn(
            "Deck TerrainLayer is unavailable in the current build.",
          );
          return null;
        }

        return new deck.TerrainLayer({
          id: "pmtiles-terrain",
          elevationData: `pmtiles://${pmtilesUrl}/{z}/{x}/{y}`,
          texture: null,
          meshMaxError: 3,
          elevationDecoder: {
            rScaler: 6553.6,
            gScaler: 25.6,
            bScaler: 0.1,
            offset: -10000,
          },
          minZoom: 5,
          maxZoom: 15,
          refinementStrategy: "no-overlap",
          operation: "terrain",
          fetch: pmtilesFetch,
          loadOptions: {
            terrain: {
              skirtHeight: 15,
            },
          },
        });
      };

      const terrainLayer = createTerrainLayer();

      const baseDeckLayers = terrainLayer ? [terrainLayer] : [];
      if (baseDeckLayers.length > 0) {
        deckgl.setProps({ layers: baseDeckLayers });
      }

      const trailLayerProps = {
        id: "heritage-trail",
        lineWidthScale: 2,
        lineWidthUnits: "pixels",
        getLineColor: [255, 0, 0],
        getLineWidth: 6,
        pickable: true,
        highlightColor: [255, 255, 0, 180],
        parameters: {
          depthTest: false,
        },
        coordinateSystem: deck.COORDINATE_SYSTEM.CARTESIAN,
        extensions: terrainExtension ? [terrainExtension] : [],
        terrainDrawMode: "offset",
        getElevation: (feature) => (feature.geometry.type === "Point" ? 12 : 6),
      };

      const currentOrbitViewState = () => {
        const center = map.getCenter();
        const centerMercator = maplibregl.MercatorCoordinate.fromLngLat(
          { lng: center.lng, lat: center.lat },
          0,
        );
        return {
          target: [centerMercator.x, centerMercator.y, centerMercator.z ?? 0],
          rotationOrbit: map.getBearing(),
          rotationX: map.getPitch(),
          zoom: map.getZoom(),
          minZoom: map.getMinZoom(),
          maxZoom: map.getMaxZoom(),
        };
      };

      const syncDeckViewState = () => {
        if (deckSyncInProgress) {
          return;
        }

        mapSyncInProgress = true;
        try {
          deckgl.setProps({
            viewState: currentOrbitViewState(),
          });
        } finally {
          mapSyncInProgress = false;
        }
      };

      const updateTooltip = (info) => {
        if (info.object) {
          const name = info.object.properties?.name;
          tooltip.textContent = name ? `Trail: ${name}` : "Heritage Trail";
          tooltip.style.display = "block";
          tooltip.style.left = `${info.x}px`;
          tooltip.style.top = `${info.y}px`;
        } else {
          tooltip.style.display = "none";
        }
      };

      const toMercatorPosition = (coords) => {
        const [lng, lat, altitude = 0] = coords;
        const mercator = maplibregl.MercatorCoordinate.fromLngLat(
          { lng, lat },
          altitude,
        );
        return [mercator.x, mercator.y, mercator.z ?? 0];
      };

      const convertGeometryToMercator = (geometry) => {
        const convert = (coordinates) => {
          if (typeof coordinates[0] === "number") {
            return toMercatorPosition(coordinates);
          }
          return coordinates.map(convert);
        };

        return {
          ...geometry,
          coordinates: convert(geometry.coordinates),
        };
      };

      const convertFeatureCollectionToMercator = (featureCollection) => ({
        ...featureCollection,
        features: featureCollection.features.map((feature) => ({
          ...feature,
          geometry: convertGeometryToMercator(feature.geometry),
        })),
      });

      const createTrailLayer = (data) =>
        new deck.GeoJsonLayer({
          ...trailLayerProps,
          data,
          autoHighlight: true,
          pointType: "circle",
          getPointRadius: 30,
          pointRadiusUnits: "meters",
          onHover: updateTooltip,
        });

      deckCanvas.addEventListener("mouseleave", () => {
        tooltip.style.display = "none";
      });

      map.on("load", () => {
        map.addSource("terrainSource", {
          type: "raster-dem",
          url: `pmtiles://${pmtilesUrl}`,
          tileSize: 256,
        });

        map.setTerrain({
          source: "terrainSource",
          exaggeration: 1,
        });

        map.addLayer({
          id: "hillshadeLayer",
          type: "hillshade",
          source: "terrainSource",
          paint: {
            "hillshade-shadow-color": "#000000",
            "hillshade-highlight-color": "#ffffff",
            "hillshade-accent-color": "#888888",
          },
        });

        map.addControl(
          new maplibregl.TerrainControl({
            source: "terrainSource",
            exaggeration: 1,
          }),
        );

        const initializeTrailLayer = async () => {
          try {
            const response = await fetch(trailDataUrl);
            if (!response.ok) {
              throw new Error(`Failed to load trail data: ${response.status}`);
            }
            const geojson = await response.json();
            const mercatorGeojson = convertFeatureCollectionToMercator(geojson);

            deckgl.setProps({
              layers: [...baseDeckLayers, createTrailLayer(mercatorGeojson)],
            });
            deckReady = true;
            syncDeckViewState();
          } catch (error) {
            console.error(
              "Unable to initialize the heritage trail layer",
              error,
            );
          }
        };

        syncDeckViewState();
        void initializeTrailLayer();
      });

      map.on("render", () => {
        if (!deckReady) {
          return;
        }

        syncDeckViewState();
      });

      map.on("resize", () => {
        deckgl.resize();
      });

      map.on("remove", () => {
        deckgl.finalize();
      });

      map.addControl(
        new maplibregl.NavigationControl({
          visualizePitch: true,
          showZoom: true,
          showCompass: true,
        }),
      );
    </script>
  </body>
</html>
