<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Display a 3D Map</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.css"
      crossorigin="anonymous"
    />
    <script
      src="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.js"
      crossorigin="anonymous"
    ></script>
    <script src="https://unpkg.com/pmtiles@4.1.0/dist/pmtiles.js"></script>
    <script src="https://unpkg.com/deck.gl@9.0.37/dist.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
      }

      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }

      #deck-overlay {
        position: absolute;
        inset: 0;
        z-index: 5;
        pointer-events: auto;
      }

      .maplibregl-ctrl-top-right {
        z-index: 6;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script>
      const {
        Deck,
        FirstPersonController,
        FirstPersonView,
        GeoJsonLayer,
        COORDINATE_SYSTEM,
        _TerrainExtension,
        TerrainExtension: PublicTerrainExtension,
      } = deck;

      const protocol = new pmtiles.Protocol();
      maplibregl.addProtocol("pmtiles", protocol.tile);
      const pmtilesUrl = "output.pmtiles";
      const pmtilesSource = new pmtiles.PMTiles(pmtilesUrl);
      protocol.add(pmtilesSource);

      const trailDataUrl =
        "LAD_Waverley_active-travel-heritage-trail-farnham.geojson";

      const map = new maplibregl.Map({
        style: "https://tiles.openfreemap.org/styles/liberty",
        container: "map", // container id
        center: [-0.796, 51.214],
        zoom: 16,
        pitch: 61,
        bearing: 0,
        maxPitch: 85,
        maxZoom: 20,
      });

      /*
       * https://deck.gl/docs/api-reference/extensions/terrain-extension
       */
      const TerrainExtension = PublicTerrainExtension || _TerrainExtension;
      const terrainExtension = TerrainExtension
        ? new TerrainExtension({ terrainDrawMode: "offset" })
        : null;

      const mapElement = document.getElementById("map");
      const deckContainer = document.createElement("div");
      deckContainer.id = "deck-overlay";
      deckContainer.style.touchAction = "none";
      mapElement.append(deckContainer);

      const tooltipFormatter = (feature) =>
        feature
          ? `Trail: ${feature.properties?.name ?? "Heritage Trail"}`
          : null;

      const firstPersonViewId = "first-person-view";
      const pitchLimits = { min: 0, max: 85 };
      const fallbackCameraAltitude = 120;
      let freeCameraWarningLogged = false;

      const clampPitch = (value) =>
        Math.max(
          pitchLimits.min,
          Math.min(pitchLimits.max, value ?? pitchLimits.min),
        );

      const getCameraAltitude = () => {
        if (typeof map.getFreeCameraOptions === "function") {
          try {
            const freeCamera = map.getFreeCameraOptions();
            const position = freeCamera?.position;
            if (position && Number.isFinite(position[2])) {
              return position[2];
            }
          } catch (error) {
            if (!freeCameraWarningLogged) {
              console.warn("Unable to read free camera options", error);
              freeCameraWarningLogged = true;
            }
          }
        }

        const cameraPosition = map?.transform?._camera?.position;
        if (cameraPosition && Number.isFinite(cameraPosition[2])) {
          return cameraPosition[2];
        }

        return fallbackCameraAltitude;
      };

      const normalizePosition = (position, altitudeFallback) => {
        if (Array.isArray(position) && position.length === 3) {
          return position.map((value, index) => {
            if (!Number.isFinite(value)) {
              if (index === 2) {
                return altitudeFallback;
              }
              return 0;
            }
            return value;
          });
        }
        return [0, 0, altitudeFallback];
      };

      const cloneViewState = (state) => ({
        longitude: state.longitude,
        latitude: state.latitude,
        bearing: state.bearing,
        pitch: state.pitch,
        zoom: state.zoom,
        position: Array.isArray(state.position)
          ? [...state.position]
          : [0, 0, fallbackCameraAltitude],
      });

      const wrapViewState = (state) => ({
        [firstPersonViewId]: cloneViewState(state),
      });

      let lastDeckViewState = cloneViewState({
        longitude: map.getCenter().lng,
        latitude: map.getCenter().lat,
        bearing: map.getBearing(),
        pitch: clampPitch(map.getPitch()),
        zoom: map.getZoom(),
        position: [0, 0, getCameraAltitude()],
      });

      const buildViewStateFromMap = () => {
        const center = map.getCenter();
        const altitudeCandidate =
          Array.isArray(lastDeckViewState.position) &&
          Number.isFinite(lastDeckViewState.position[2])
            ? lastDeckViewState.position[2]
            : getCameraAltitude();
        const altitude = Number.isFinite(altitudeCandidate)
          ? altitudeCandidate
          : fallbackCameraAltitude;

        return {
          longitude: center.lng,
          latitude: center.lat,
          bearing: map.getBearing(),
          pitch: clampPitch(map.getPitch()),
          zoom: map.getZoom(),
          position: normalizePosition(lastDeckViewState.position, altitude),
        };
      };

      const normalizeDeckViewState = (state) => {
        const normalized = {
          longitude: state.longitude ?? lastDeckViewState.longitude,
          latitude: state.latitude ?? lastDeckViewState.latitude,
          bearing: state.bearing ?? lastDeckViewState.bearing,
          pitch: clampPitch(state.pitch ?? lastDeckViewState.pitch),
          zoom: state.zoom ?? lastDeckViewState.zoom,
          position: normalizePosition(
            state.position,
            Number.isFinite(lastDeckViewState.position?.[2])
              ? lastDeckViewState.position[2]
              : getCameraAltitude(),
          ),
        };

        lastDeckViewState = normalized;
        return cloneViewState(normalized);
      };

      let syncingFromDeck = false;
      let syncingFromMap = false;

      const deckInstance = new Deck({
        parent: deckContainer,
        views: [
          new FirstPersonView({
            id: firstPersonViewId,
            controller: {
              type: FirstPersonController,
              dragMode: "rotate",
              dragPan: true,
              keyboard: true,
              scrollZoom: true,
            },
          }),
        ],
        initialViewState: wrapViewState(lastDeckViewState),
        viewState: wrapViewState(lastDeckViewState),
        layers: [],
        getTooltip: ({ object }) => tooltipFormatter(object),
        onViewStateChange: ({ viewState, viewId }) => {
          if (syncingFromMap || viewId !== firstPersonViewId) {
            return;
          }

          const fpState = viewState?.[viewId] ?? viewState;
          if (!fpState) {
            return;
          }

          const normalizedState = normalizeDeckViewState(fpState);

          syncingFromDeck = true;
          const targetCenter = [
            normalizedState.longitude,
            normalizedState.latitude,
          ];

          map.jumpTo({
            center: targetCenter,
            bearing: normalizedState.bearing,
            pitch: normalizedState.pitch,
            zoom: normalizedState.zoom,
          });
          syncingFromDeck = false;
          syncDeckFromMap();
        },
      });

      const syncDeckFromMap = () => {
        if (syncingFromDeck) {
          return;
        }

        syncingFromMap = true;
        const nextState = buildViewStateFromMap();
        lastDeckViewState = cloneViewState(nextState);
        deckInstance.setProps({ viewState: wrapViewState(lastDeckViewState) });
        syncingFromMap = false;
      };

      const disableMapGestures = () => {
        map.dragPan.disable();
        map.dragRotate.disable();
        map.scrollZoom.disable();
        map.doubleClickZoom.disable();
        map.touchZoomRotate.disable();
        map.keyboard.disable();
        map.boxZoom.disable();
      };

      map.on("move", syncDeckFromMap);

      const getPmtilesInstance = (() => {
        const cache = new Map();
        return (archivePath) => {
          if (cache.has(archivePath)) {
            return cache.get(archivePath);
          }
          const instance =
            protocol.get(archivePath) ?? new pmtiles.PMTiles(archivePath);
          protocol.add(instance);
          cache.set(archivePath, instance);
          return instance;
        };
      })();

      const pmtilesImageResponse = (tile) => {
        if (!tile || !tile.data) {
          return new Response(null, { status: 204 });
        }

        const dataView =
          tile.data instanceof ArrayBuffer
            ? tile.data
            : tile.data.buffer.slice(
                tile.data.byteOffset,
                tile.data.byteOffset + tile.data.byteLength,
              );

        const headers = new Headers({ "Content-Type": "image/png" });
        if (tile.cacheControl) {
          headers.set("Cache-Control", tile.cacheControl);
        }
        if (tile.expires) {
          headers.set("Expires", tile.expires);
        }

        return new Response(dataView, { status: 200, headers });
      };

      const pmtilesFetch = async (url, options = {}) => {
        if (!url.startsWith("pmtiles://")) {
          return fetch(url, options);
        }

        const matches = url.match(/^pmtiles:\/\/(.+?)\/(\d+)\/(\d+)\/(\d+)$/);
        if (!matches) {
          throw new Error(`Unexpected PMTiles request: ${url}`);
        }

        const [, archivePath, z, x, y] = matches;
        const archive = getPmtilesInstance(archivePath);
        const tile = await archive.getZxy(
          Number.parseInt(z, 10),
          Number.parseInt(x, 10),
          Number.parseInt(y, 10),
          options.signal,
        );

        return pmtilesImageResponse(tile);
      };

      const defaultTerrainBounds = [-180, -85.05113, 180, 85.05113];
      const terrainDecoder = {
        rScaler: 6553.6,
        gScaler: 25.6,
        bScaler: 0.1,
        offset: -10000,
      };

      const terrainConfigPromise = pmtilesSource
        .getHeader()
        .then((header) => {
          if (
            header &&
            Number.isFinite(header.minLon) &&
            Number.isFinite(header.minLat) &&
            Number.isFinite(header.maxLon) &&
            Number.isFinite(header.maxLat)
          ) {
            return [header.minLon, header.minLat, header.maxLon, header.maxLat];
          }
          return defaultTerrainBounds;
        })
        .catch(() => defaultTerrainBounds);

      const baseTerrainConfig = {
        elevationData: `pmtiles://${pmtilesUrl}/{z}/{x}/{y}`,
        texture: null,
        elevationDecoder: terrainDecoder,
        fetch: pmtilesFetch,
        minZoom: 5,
        maxZoom: 15,
        skirtHeight: 15,
      };

      const createTerrainExtensionConfig = (bounds) =>
        terrainExtension ? { ...baseTerrainConfig, bounds } : null;

      const trailLayerProps = {
        id: "heritage-trail",
        lineWidthScale: 2,
        lineWidthUnits: "pixels",
        getLineColor: [255, 0, 0],
        getLineWidth: 6,
        pickable: true,
        highlightColor: [255, 255, 0, 180],
        coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
        extensions: terrainExtension ? [terrainExtension] : [],
        terrainDrawMode: "offset",
        getElevation: (feature) => (feature.geometry.type === "Point" ? 12 : 6),
      };

      const createTrailLayer = (data, terrainConfig) =>
        new GeoJsonLayer({
          ...trailLayerProps,
          data,
          autoHighlight: true,
          pointType: "circle",
          getPointRadius: 12,
          pointRadiusUnits: "pixels",
          terrain: terrainConfig || undefined,
        });

      map.on("load", () => {
        disableMapGestures();
        map.getCanvas().style.pointerEvents = "none";
        deckContainer.style.pointerEvents = "auto";
        syncDeckFromMap();

        map.addSource("terrainSource", {
          type: "raster-dem",
          url: `pmtiles://${pmtilesUrl}`,
          tileSize: 256,
        });

        map.setTerrain({
          source: "terrainSource",
          exaggeration: 1,
        });

        map.addLayer({
          id: "hillshadeLayer",
          type: "hillshade",
          source: "terrainSource",
          paint: {
            "hillshade-shadow-color": "#000000",
            "hillshade-highlight-color": "#ffffff",
            "hillshade-accent-color": "#888888",
          },
        });

        map.addControl(
          new maplibregl.TerrainControl({
            source: "terrainSource",
            exaggeration: 1,
          }),
        );

        const initializeTrailLayer = async () => {
          try {
            const [bounds, response] = await Promise.all([
              terrainConfigPromise,
              fetch(trailDataUrl),
            ]);
            if (!response.ok) {
              throw new Error(`Failed to load trail data: ${response.status}`);
            }
            const geojson = await response.json();
            const terrainConfig = createTerrainExtensionConfig(bounds);

            deckInstance.setProps({
              layers: [createTrailLayer(geojson, terrainConfig)],
            });
          } catch (error) {
            console.error(
              "Unable to initialize the heritage trail layer",
              error,
            );
          }
        };

        void initializeTrailLayer();
      });

      map.addControl(
        new maplibregl.NavigationControl({
          visualizePitch: true,
          showZoom: true,
          showCompass: true,
        }),
      );
    </script>
  </body>
</html>
